---
layout: post
title: Provisioning with Azure Resource Manager templates
date: '2021-01-02T12:10:00.000+01:00'
author: Stefan Szarek
tags:
- Azure
- cloud
modified_time: '2021-01-06T16:31:41.623+01:00'
thumbnail: https://1.bp.blogspot.com/-e9e4hDGvlyU/X-iuvkjWIpI/AAAAAAAAAq8/Cg57w7IhS8k9Xbr-v2_tj_5s4uRAlyuAACLcBGAsYHQ/s72-w640-c-h317/subscriptions.png
blogger_id: tag:blogger.com,1999:blog-1400779654511127347.post-1824654817181348115
blogger_orig_url: https://sszarek.blogspot.com/2021/01/provisioning-with-azure-resource.html
---

<h2 style="text-align: left;">Provisioning cloud resources</h2><div>Cloud providers offer lots of services to be used by developers. The mentioned services range from traditional virtual machines, through storage solutions to AI tooling. Each of them is just smaller or bigger building block which can be used when putting together more complex system.</div><div>When starting your journey with cloud you will probably be amazed with what you will see in various tutorials: with few clicks in AWS/Azure/Google cloud console you can provision all the stuff which is needed for running your cool application. In fact clicking through the cloud provider UI is great when learning and you just want to play with this stuff.</div><div>While great for learning purposes this approach does not scale when:</div><div><ul style="text-align: left;"><li>Working on bigger cloud project where you need to provision lots of stuff</li><li>Working with the team</li><li>You need to create additional environments and cloud infrastructure should be the same</li></ul><div>The reason why the approach mentioned above does not scale is because it is manual process, and since its manual it is hardly reproducible. Imagine situation where you would like to setup additional testing environment which should be only accessible from internal network of your company. Even assuming that you have only few resources running this would be tedious job (creating storage, setting up networking rules, permissions etc.).</div></div><p style="text-align: left;">Fortunately for Azure we have Azure Resource Manager templates which help to address the issues described above. Note that there are also other tools available for performing this task e.g. Terraform - however these are out of scope for this article.&nbsp;</p><h2 style="text-align: left;">What is Azure Resource Manager (ARM)?</h2><div>Azure Resource Manager is a layer which sits between Azure resources (e.g. Blobs, Functions) and various interfaces such as:</div><div><ul style="text-align: left;"><li>Azure Portal</li><li>SDK's</li><li>REST API's</li><li>Command line tools</li></ul><div>It is responsible for performing authentication and authorization of requests and forwarding them to services responsible for management of specific resources.</div></div><p style="text-align: left;">One of the benefits of ARM is that it allows you to manage you infrastructure with so called templates - these are JSON's containing definition of resources to be created/updated. This article will describe format and some basic features of ARM templates through simple example of creating Azure Storage Account with Blob container.</p><h2 style="text-align: left;">Login to Azure and setup default subscription</h2><div>Lets start from logging in to your Azure account from Azure CLI. If you don't have tool installed, you will need to install it by following instruction from <a href="https://docs.microsoft.com/pl-pl/cli/azure/install-azure-cli">this page</a>.</div><div><pre><code class="bash">az login</code></pre></div><div style="text-align: left;">The command will guide you in the process of logging in to your Azure account - after logging in you will be able to execute commands against your Azure account with Azure CLI.&nbsp;</div><p style="text-align: left;">Next step will be setting default subscription - it is the subscription used by default when using the tool so that you don't have to provide it explicitly. In case you would like to use different subscription you will need to change default setting or explicitly provide different one.</p><div style="text-align: left;"><pre><code class="bash">az account list --output table<br />az account set --subscription "Subscription of your choice"</code></pre></div><div style="text-align: left;">The first of the above commands will list all subscriptions you have access to formatted as table - which is quite useful when setting default subscription. Screenshot below presents sample output from the command.</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-e9e4hDGvlyU/X-iuvkjWIpI/AAAAAAAAAq8/Cg57w7IhS8k9Xbr-v2_tj_5s4uRAlyuAACLcBGAsYHQ/s1091/subscriptions.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="539" data-original-width="1091" height="317" src="https://1.bp.blogspot.com/-e9e4hDGvlyU/X-iuvkjWIpI/AAAAAAAAAq8/Cg57w7IhS8k9Xbr-v2_tj_5s4uRAlyuAACLcBGAsYHQ/w640-h317/subscriptions.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>The second command is simply setting default subscription, as you can see there is only single <i>--subscription</i> parameter - you can provide subscription name or id, which values can be found in the table generated by the previous command.<br /><h2 style="text-align: left;">Create Resource Group</h2><div>Before we jump into creation of the template we will create Resource Group which will contain resources we will provision later on. We will do that by using another command from Azure CLI.</div><div><pre><code class="bash">az group create --location eastus --name my-infra-rg</code></pre></div><div>The above command will instruct Azure to create <i>my-infra-rg</i> Resource Group in default subscription in East US region. Note that the location (region) you are setting when creating Resource Group determines where Azure is storing metadata (e.g. about deployments) for resources contained in the group - the resources itself can be located in any location you want. This has some implications - suppose that you have Resource Group in Central US and resources in East US - when the first goes down you will not be able to perform new deployments to that group, however the resources itself should be working properly.</div><p style="text-align: left;">After successfully finishing its job, the above command should provide output similar to one on the screenshot below.</p><p style="text-align: left;"></p><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ez8sj9kd2xI/X-yPC281iqI/AAAAAAAAArg/GelgnRaRaKMqCsBzWMeZLk_GgPxttrC3gCLcBGAsYHQ/s901/resource-group-creation.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="235" data-original-width="901" height="166" src="https://1.bp.blogspot.com/-ez8sj9kd2xI/X-yPC281iqI/AAAAAAAAArg/GelgnRaRaKMqCsBzWMeZLk_GgPxttrC3gCLcBGAsYHQ/w640-h166/resource-group-creation.png" width="640" /></a></div><br />The information which is important here are:<p></p><p style="text-align: left;"></p><ul style="text-align: left;"><li><i>id</i> - this is resource Id of the resource group you have just created. It includes subscription Id, which I obfuscated on the screenshot.</li><li><i>properties.provisioningState</i> - this property informs you about the status of the provisioning. In this case it was successful.</li></ul><p></p><h2 style="text-align: left;">Create ARM template</h2><div>Now we are ready to start creating template itself. Create directory where you would like to store your template. In the directory create <i>azuredeploy.json</i> file and paste the content of the snippet below. You can use every code editor you want. In case you are using Visual Studio Code there is <a href="https://marketplace.visualstudio.com/items?itemName=msazurermtools.azurerm-vscode-tools">extension</a> available for Azure Resource Manager which provides: syntax highlighting, code completion and tons of snippets helpful when creating ARM template.</div>  <pre>  <code class="json">{<br />    "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",<br />    "contentVersion": "1.0.0.0",<br />    "parameters": {},<br />    "functions": [],<br />    "variables": {},<br />    "resources": [],<br />    "outputs": {}<br />}</code> </pre>  </div><div style="text-align: left;">There are several properties in created JSON file which configure different aspects of template:<br /><ul style="text-align: left;"><li><i>parameters</i> - contains values which allow you to re-use template e.g. across different environments</li><li><i>functions</i> - ARM templates do contains lots of built-in helper functions which allow you to e.g. operate on text strings, extract keys and connection strings from other resources. Full list of available functions is available <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions">here</a>. The property contains so called user-defined functions which are compositions of built in functions.&nbsp;</li><li><i>variables</i> - contains variables which you want to re-use inside your template. It is especially useful in case of values computed with functions.</li><li><i>resources</i> - this is the most important property, it is where you define Azure resources to be created.</li><li><i>outputs</i> - contains values you want to... well output after deployment. If the template is so called linked template (this is out of scope for this post, in short this is option for re-using templates), values listed in output section can be used in template which references linked templated. You can also use it when executing some automation.</li></ul><h2 style="text-align: left;">Add Storage Account with Blob container</h2><div>Now we will add definitions for Storage Account and Blob container associated with it. Add code from snippet below to resources section of <i>azuredeploy.json</i> file.</div><div>    <pre><code class="json">{<br />    "name": "provisionwarmtemplate",<br />    "type": "Microsoft.Storage/storageAccounts",<br />    "apiVersion": "2019-06-01",<br />    "tags": {<br />        "displayName": "provisioningWithArmTemplatesSA"<br />    },<br />    "location": "[resourceGroup().location]",<br />    "kind": "StorageV2",<br />    "sku": {<br />        "name": "Standard_LRS",<br />        "tier": "Standard"<br />    },<br />    "resources": [<br />        {<br />            "type": "blobServices/containers",<br />            "apiVersion": "2019-06-01",<br />            "name": "[concat('default/', 'my-storage-container')]",<br />            "dependsOn": [<br />                "[resourceId('Microsoft.Storage/storageAccounts', 'provisionwarmtemplate')]"<br />            ]<br />        }<br />    ]<br />}<br />    </code></pre></div><div style="text-align: left;">There are few things to note about the code above:</div><div style="text-align: left;"><ul style="text-align: left;"><li>It is creating two resources Storage Account with name <i>provisionwarmtemplate</i> and Blob container <i>my-storage-container</i> which is nested resource dependent on the Storage Account.</li><li>For Storage Account we are setting location property which will define region where it will be deployed. The location is set with use of function <i>resourceGroup()</i> which returns object describing resource group in which resource is being deployed. Luckily for us this object does contain <i>location</i> property. It is important to note that the function is only available when deploying at Resource Group level. If the value is being set with functions, the string is wrapped with square braces - when using Visual Studio Code extension for ARM, you will get syntax highlighting and completion for these.</li><li>Blob container <i>my-storage-container</i> is added as a nested resource to Storage Account - because of that it has to include <i>dependsOn</i> property. The property instructs Azure Resource Manager that it should create Storage Account first and then Blob container. This has to be explicitly set for nested resources. Similarly to <i>location</i>, the value is set with function - in this case it is <i>resourceId</i> function which resolves Id of the resources. First argument of the function is resource type, the second one resource name.</li><li>Both resources do include <i>apiVersion</i> property - it defines which version of the API should be used for handling deployment of specific resources. Each resource has its own distinct set of API versions. Newer versions of the API can have some additional features, on the other hand they may deprecate others.</li></ul></div><h2 style="text-align: left;">Refactoring</h2><div>If you look at the resulting code you will find that there is lots of hardcoded stuff here:</div><div><ul style="text-align: left;"><li>Name of the Storage Account</li><li>Name of the Blob container</li><li>Location of Storage Account - it is set to the same location as Resource Group where you are deploying</li></ul><div>In one of the previous sections I have mentioned that ARM templates allow parametrization with <i>parameters</i> property. Lets leverage that feature to parametrize the template.</div></div><div><br /></div><div><i>parameters</i> property is an JSON object, the keys are parameter names and values are objects describing parameter. Lets take a closer look on that - the snippet below contains parameters property of the template filled with parameter for setting name of the Storage Account.</div><div><pre><code>"parameters": {<br />    "storageAccountName": {<br />        "type": "string",<br />        "metadata": {<br />            "description": "Storage Account name"<br />        }<br />    }<br />}</code></pre></div><div style="text-align: left;">The parameter above is described by two properties:</div><div style="text-align: left;"><ul style="text-align: left;"><li><i>type</i> - which defines type of the property value. You can fined complete list of types <a href="https://docs.microsoft.com/pl-pl/azure/azure-resource-manager/templates/template-syntax#data-types">here</a>.</li><li><i>metadata.description</i> - description of the parameter - it is useful when you want to provide more information about how the parameter is being used.</li></ul>Additionally you can also set list of allowed values (<i>allowedValues</i> property) or default value (<i>defaultValue</i> property).</div><div style="text-align: left;">When you define parameter you can reference it by using <i>parameters()</i> function e.g. <i>"[parameters('storageAccount')]"</i>&nbsp;- it accepts single argument which is name of the parameter. As an exercise, finish refactoring of the template. <a href="https://github.com/sszarek/provisioning-with-azure-resource-manager">This GitHub repository</a> contains code for this example.</div><p style="text-align: left;">The final step for the refactoring is creating parameters file which will be used when deploying resources. Create&nbsp;<i>azuredeploy.parameters.json</i> and paste snippet below into its content.</p>    <pre><code class="json">{<br />    "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#",<br />    "contentVersion": "1.0.0.0",<br />    "parameters": {<br />        "storageAccountName": {<br />            "value": "provisionwarmtemplate"<br />        },<br />        "location": {<br />            "value": "eastus"<br />        },<br />        "containerName": {<br />            "value": "my-storage-container"<br />        }<br />    }<br />}</code></pre><div style="text-align: left;">With parameter files you can e.g. reuse template for performing deployment to different environments&nbsp; (in such scenario you could have separate parameters file per environment).</div><h2 style="text-align: left;">Deployment</h2><div>The last step is performing actual deployment. We will do that with Azure CLI. Command below will deploy resources defined in the template to <i>my-infra-rg</i> Resource Group using parameter values defined in <i>azuredeploy.parameters.json</i>.</div><pre><code class="bash">az deployment group create --resource-group my-infra-rg --template-file .\azuredeploy.json --parameters .\azuredeploy.parameters.json</code></pre><div style="text-align: left;">Now you should see newly created Storage Account in Azure Portal. Of course there is a way to list Storage Accounts from <i>my-infra-rg</i> Resource Group with Azure CLI, you can do that by running command below.</div><div style="text-align: left;"><pre><code class="bash">az storage account list --query "[?resourceGroup == 'my-infra-rg'].{Name:name, Location:location, ResourceGroup:resourceGroup}" --output table</code></pre></div><div style="text-align: left;">When you are finished with playing with templates it is good idea to remove resources you will not be using. Since we have put all the resources for the exercise in <i>my-infra-rg</i> Resource Group, we can just delete the group - this operation will remove all the resources associated with it. For removing Resource Group we will use following command.</div><div style="text-align: left;"><pre><code class="bash">az group delete --name my-infra-rg</code></pre></div><p style="text-align: left;">That's it for this article. Now you can go and play by creating template for e.g. project you are working on right now. There are tons of information about Azure Resource Manager in Microsoft docs (linked in <b>More reading</b> section below) and <a href="https://github.com/Azure/azure-quickstart-templates">azure-quickstart-templates</a> GitHub repository does contain some sample templates for provisioning common resources.</p><h2 style="text-align: left;">More reading</h2><div><a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/overview">Overview of ARM on Microsoft Docs</a></div><div><a href="https://docs.microsoft.com/pl-pl/azure/azure-resource-manager/templates/template-functions">List of all template functions</a></div><div><a href="https://docs.microsoft.com/en-us/azure/templates/">Resources reference for Azure Resource Manager</a></div></div>